<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tommy&#39;s blog</title>
    <link>https://tommy0121.github.io/</link>
    <description>Recent content on tommy&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 29 Apr 2020 14:17:22 +0800</lastBuildDate>
    
        <atom:link href="https://tommy0121.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java Avoid Not Equal Null</title>
      <link>https://tommy0121.github.io/post/java-avoid-not-equal-null/</link>
      <pubDate>Wed, 29 Apr 2020 14:17:22 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/java-avoid-not-equal-null/</guid>
      
        <description>&lt;p&gt;  &lt;strong&gt;太长不想看：使用Java8开始能用Optional类包装Object。&lt;/strong&gt;  代码如下
&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-29/1c9c208f.png&#34; alt=&#34;&#34;&gt;&lt;br&gt;
  正文。&lt;br&gt;
  无聊开始看看Java，然后心血来潮，准备把之前做过的IOC和Proxy的代理demo升级一下。做一个简单的aspectj，基础功能大概就是给方法添加注解，注解内指定类以及方法，然后在执行指定方法的同时，执行加了注解的方法。具体功能参照aspectj，但是挑几个好实现的@Before和@After实现。&lt;br&gt;
  在review之前的代码的时候发现这么一串代码&lt;br&gt;
&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-29/438db2eb.png&#34; alt=&#34;example&#34;&gt;&lt;br&gt;
  可以看到红色框框内有俩if(object!=null)的判断，算上上面的url!=null总共三个非空判断。说实话，写习惯JavaScript的我现在看到这个代码就有点脑壳痛了。这种if(true) 执行，false不做执行的代码块，在JavaScript里面比较常见用链式写法，类似于 a.isNull( input =&amp;gt; { doSomething() return result; } ).then(result =&amp;gt; result === null).then(condition =&amp;gt; {});这种链式写法在我眼中可读性更高，在读代码的时候不会因为一个!=null就脑子一卡。所以在写功能之前，我想先找办法把这个大量非空判断解决掉。&lt;br&gt;
  非常让人开心的是，在bing直接搜java avoid !=null statement，发现早有人在StackOverflow上面问过了(没有什么问题是StackOverflow上面没有的，如果有，换个表述方式再搜一遍)。里面的最高票答案推荐了两个办法，1：使用assert来定义成员属性，这就算了，完全不是这里的需求。2：自个儿写类和方法去包装object，这也算了&amp;hellip;.虽然有示例代码，但是说实话问题复杂化了。&lt;br&gt;
  最后找到一个回答说Java8开始推荐使用Optional类，确实挺好用的，可以用Optional.ofNullable(object).ifPresent(object -&amp;gt;{doSomething()})。形式避免非空判断，但是由于Java的lambda表达式有点问题，我们无法在lambda表达式外catch住lambda内部的exception，所以里面的代码如果throw exception的话，我们就需要在里面写一份try catch，连直接声明throws exception都不行。具体可以看最上面的图。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>React Diff</title>
      <link>https://tommy0121.github.io/post/diff/</link>
      <pubDate>Fri, 10 Apr 2020 13:27:00 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/diff/</guid>
      
        <description>&lt;p&gt;  emm会用react，咱都知道react用virtual dom的形式解耦了视图层级和代码的交互操作。&lt;br&gt;
  既然托管了view层次的生成，react必然得提供高效的视图生成，不然如果组件之间的转换卡顿严重一定是所有人都受不了的。所以呢，在渲染html方面，react整了个diff算法，提升了html重新渲染的速度。&lt;br&gt;
  废话不多说这里先推荐两篇文章，后面写的东西基本都是对于这两篇文章的思路(图片资源也是这里扒下来的= =)。&lt;br&gt;
  1：&lt;a href=&#34;https://github.com/hujiulong/blog/issues/6#&#34;&gt;从零开始实现一个React（三）：diff算法&lt;/a&gt;&lt;br&gt;
  2：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/20346379&#34;&gt;React 源码剖析系列 － 不可思议的 react diff&lt;/a&gt;&lt;br&gt;
  首先咱声明以及明确以下几点。&lt;br&gt;
  1：react的diff算法对于新旧两颗dom树只会对&lt;strong&gt;同一层级的节点进行比较，如果类型不同，旧的节点将会直接删除重建&lt;/strong&gt;即使是有跨层级移动的节点(节点内容相同，但是新的节点深度和旧节点深度不同)，也是直接删了重建，而不会进行节点移动。&lt;br&gt;
  2：新旧两颗树在进行比较之后并不会直接去更新旧树，而是生成一个个patch，然后执行方法根据patch去更新旧树。(在推荐的第一篇文章中由于并没有两颗virtual dom树，用的virtual dom直接和html节点比较，所以它是是直接更新了旧树)。&lt;br&gt;
  3：由于react的virtual dom有多种形式，原生的html element标签，自定义的component，字符串，实际上的dom比较还是比较繁琐的，为了简化代码理解，所以这里在后面的代码中默认都是同类型的标签数组。&lt;/p&gt;
&lt;p&gt;这里定义简单一个TreeNode&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReactNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;tag&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;attrs&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;object&lt;/span&gt;;
  &lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;ReactNode&lt;/span&gt;[] &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;[];
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后写diff方法，这里由于咱默认没有string类型以及component类型的节点，所以我们只需要比较当新节点的tag类型和旧节点的tag类型是否一致。不一样的就删了重新建立。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;diffNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;preNode&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;ReactNode&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;currentNode&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;ReactNode&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
  
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preNodeT&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReactNode&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;curNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentNode&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReactNode&lt;/span&gt;;
  &lt;span style=&#34;color:#75715e&#34;&gt;// tag类型不同时直接销毁原node，创建新node。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;preNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preNodeT&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tag&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;toLowerCase&lt;/span&gt;() &lt;span style=&#34;color:#f92672&#34;&gt;!==&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;curNode&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;tag&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;toLowerCase&lt;/span&gt;()) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;preNodeT&lt;/span&gt;) {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;preNode&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;tag&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;curNode.tag&lt;/span&gt;,
        &lt;span style=&#34;color:#a6e22e&#34;&gt;attrs&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;curNode.attrs&lt;/span&gt;,
        &lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;curNode.children&lt;/span&gt;
      };
    }
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (
    (&lt;span style=&#34;color:#a6e22e&#34;&gt;preNodeT&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preNodeT&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;
    (&lt;span style=&#34;color:#a6e22e&#34;&gt;curNode&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;curNode&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
  ) {
&lt;span style=&#34;color:#75715e&#34;&gt;//关键方法是这个。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;diffChildren&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;preNodeT&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;curNode&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;children&lt;/span&gt;);
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键的在同级比较以及同级节点交换的地方，我相信搜索过diff并且看过一些diff的文章的人都熟悉这么一张同级比较的图。
&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-16/b2fc70ac.jpg&#34; alt=&#34;diff&#34;&gt;&lt;br&gt;
  如果用上述说的不同则删除的说法来处理同级比较的话，react diff算法就没啥好讲了，事实上，在同级计算中用key作为element的唯一标识符，在新旧node的key相同的一些情况下可以直接移动节点而不用删除再创建节点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;


&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;diffChildren&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  (&lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;ReactNode&lt;/span&gt;[], &lt;span style=&#34;color:#a6e22e&#34;&gt;currentChildren&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;ReactNode&lt;/span&gt;[]) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {

  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preKeyArray&lt;/span&gt;:&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;attrs&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;];
  });
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentKeyArray&lt;/span&gt;:&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentChildren&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;attrs&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;];
  });

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;currentChildren&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentChildren&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
    &lt;span style=&#34;color:#75715e&#34;&gt;//  lastIndex 作为旧树中已经比较过的节点最右的位置
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lastIndex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#75715e&#34;&gt;// 遍历新树，preIndex 就是作为旧树的地址下标。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#a6e22e&#34;&gt;currentChildren&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;forEach&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;currentNode&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentKey&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentNode&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;key&amp;#34;&lt;/span&gt;];
        &lt;span style=&#34;color:#75715e&#34;&gt;// 新树的key同时存在于旧树
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;preKeyArray&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;includes&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;currentKey&lt;/span&gt;)) {
          &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preKeyArray&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;indexOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;currentKey&lt;/span&gt;)
          &lt;span style=&#34;color:#75715e&#34;&gt;// 仅当当前旧树中的节点位置比lastIndex小的时候需要移动节点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// 因为这意味着这个节点的新位置将会破坏旧位置的顺序，所以需要进行移动
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lastIndex&lt;/span&gt;) {
            &lt;span style=&#34;color:#75715e&#34;&gt;// moveChild(preIndex,currentIndex)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt;];
          }
          &lt;span style=&#34;color:#a6e22e&#34;&gt;lastIndex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;lastIndex&lt;/span&gt;);
        }
        &lt;span style=&#34;color:#75715e&#34;&gt;// 新树的key不存在旧树的时候
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;{
          &lt;span style=&#34;color:#75715e&#34;&gt;// 旧树同位置节点存在则删除旧节点并且创建节点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// 否则直接创建节点
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;]) {
            &lt;span style=&#34;color:#a6e22e&#34;&gt;lastIndex&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Math.&lt;span style=&#34;color:#a6e22e&#34;&gt;max&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;lastIndex&lt;/span&gt;);
            &lt;span style=&#34;color:#75715e&#34;&gt;// removeChild(preChildren[currentIndex])
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;undefined&lt;/span&gt;;
          }
          &lt;span style=&#34;color:#75715e&#34;&gt;// createChild(currentNode,preIndex);
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;          &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentNode&lt;/span&gt;;
        }
        &lt;span style=&#34;color:#a6e22e&#34;&gt;diffNode&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt;],&lt;span style=&#34;color:#a6e22e&#34;&gt;currentChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;currentIndex&lt;/span&gt;])
        &lt;span style=&#34;color:#a6e22e&#34;&gt;preIndex&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;;
    });

    &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;forEach&lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt;{
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;currentKeyArray&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;includes&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;item&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;attrs&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;])) {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;preChildren&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;undefined&lt;/span&gt;;
        &lt;span style=&#34;color:#75715e&#34;&gt;// removeChild(item)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      }
    });
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  基本的diff大概就是这样了，这里用了两个测试用例。分别是：旧树key为1234，新树key为2143，以及旧树key为1234，新树key为214，结果如下所示&lt;br&gt;
&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-16/dacd2a71.png&#34; alt=&#34;test case1&#34;&gt;&lt;br&gt;
&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-16/93ed2993.png&#34; alt=&#34;test case2&#34;&gt;&lt;br&gt;
  但说实话要完全实现的话还是比较复杂的，要比对是否为react element还是component，要对attribute就行比较，节点删除又专门的unMount方法，但是咱也不可能真就复制一份react代码呗。而且现在react开始使用fiber结构(就是说这个方法过时了= =)，上面文章2的代码都得去react之前的release去找了&amp;hellip;&lt;br&gt;
  但是(震声)！咱也不是白看的diff啊，咱至少知道了key有啥用不是。&lt;br&gt;
  写代码要是细一点，就该把所有的位置有可能变化的列表数据都给他添上唯一性ID，即使后台给的数据，我们也可以在获得数据的同时自己给他加一个不变的唯一性id，不加的话，这可都是新建以及销毁的开销是吧。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>前端本地依赖</title>
      <link>https://tommy0121.github.io/post/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAreact%E7%8E%AF%E5%A2%83%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%8E%AF%E5%A2%83%E4%BA%8C/</link>
      <pubDate>Thu, 15 Aug 2019 14:55:22 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAreact%E7%8E%AF%E5%A2%83%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%8E%AF%E5%A2%83%E4%BA%8C/</guid>
      
        <description>&lt;p&gt;  上次写的简单搭建一个react环境(一)，简单的整了几个常用的组件库，然后整了个test的set up。然而，当我做到一些用node写api的时候，发现有大量可复用的组件完全可以抽出来给服务端和客户端共同使用，最简单的就是接口类型定义，咱总不可能接口类型每个都在前后端项目存一份吧。&lt;/p&gt;
&lt;p&gt;  事实上工作的项目上面也是一大堆的东西单独抽出来放到lib。类似于数据的类型信息，接口方法的类型信息，还有与业务关系不大的纯辅助函数(虽然这种辅助的算法函数第三方包多的是..)，其实都是可以放到第三方包的。&lt;/p&gt;
&lt;p&gt;  在这里就记录一下如何构建一个包含前后端并且拥有本地依赖的项目。&lt;/p&gt;
&lt;p&gt;  首先在项目同级目录建立一个node项目作为服务器项目，一个lib项目放自己的依赖项。&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-519df74c758b5a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;structure&#34;&gt;&lt;br&gt;
  目前来说有看到npm以及yarn都可以做到依赖本地项目，如果需要比较深度的本地管理，lerna提供的特性比较多一点。由于没有尝试过lerna，后面仅介绍如何用npm以及yarn来构建本地依赖&lt;/p&gt;
&lt;h2 id=&#34;npm&#34;&gt;npm&lt;/h2&gt;
&lt;p&gt;  npm可以用link和install，install 指令可以直接npm install &amp;laquo;dependency project name&amp;raquo;，npm link的方法烦的多：首先在chatroom-model运行npm link，这个时候chatroom-model会被加入到npm的全局module中，然后在需要依赖这个模块的项目中输入&lt;strong&gt;npm link &amp;laquo;your dependency project name&amp;raquo;&lt;/strong&gt;，然后在模块中的package.json添上依赖的名字，运行npm install，然后可以自己去node_modules确认一下模块是否存在即可。如果没有的话，可以把package-lock.json删了再运行npm install就行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;your dependency project name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;
  }&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;,&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  然而不管是用npm install还是npm link都需要自己去每个依赖项目下面进行一些操作。而且类似于npm link 这种将项目预先发布本地&amp;hellip;.我怀疑项目发布到GitHub用另一台电脑把项目拉下来后会需要再次手动link一次，具体会不会没有试过，因为发现yarn更好用更方便就失去了尝试的想法了&lt;/p&gt;
&lt;h2 id=&#34;yarn&#34;&gt;yarn&lt;/h2&gt;
&lt;p&gt;  先贴一个yarn的官方workspace的文档&lt;a href=&#34;https://yarn.bootcss.com/docs/workspaces/&#34;&gt;yarn workspace&lt;/a&gt;。&lt;br&gt;
  首先，我们在总的根目录中创建一个package.json，内容为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;private&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;,
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;workspaces&amp;#34;&lt;/span&gt;: [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;workspace-a&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;workspace-b&amp;#34;&lt;/span&gt;]
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;具体结构如下图所示。&lt;/p&gt;
&lt;p&gt;  yarn的workspace会把package.json里面的项目的共同依赖抽取出来放到根目录下的node_modules中，同时所有的项目也会被加入到根目录的node_modules中(本质上就是创建了一个创建快捷方式)。&lt;br&gt;
  &lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-21/9ad4f18c.png&#34; alt=&#34;结构&#34;&gt;&lt;br&gt;
  这个时候其实就已经完成了本地依赖了，唯一要注意的是一般来说，通用的依赖项目，比如上图所示的接口定义的model，我们的项目入口都是build出来的dist或者build文件夹中的index(其实也是看具体项目，反正就是package.json里面定义的main)。所以在每次修改完lib的时候记得build(一开始被这玩意儿坑惨了)&lt;br&gt;
&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-21/e480a474.png&#34; alt=&#34;entry&#34;&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>简单搭建一个react开发环境</title>
      <link>https://tommy0121.github.io/post/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAreact%E7%8E%AF%E5%A2%83%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%8E%AF%E5%A2%831/</link>
      <pubDate>Wed, 07 Aug 2019 15:03:33 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAreact%E7%8E%AF%E5%A2%83%E5%B7%A5%E7%A8%8B%E5%8C%96%E7%8E%AF%E5%A2%831/</guid>
      
        <description>&lt;h2 id=&#34;1一个正常的前端工程化环境&#34;&gt;1一个正常的前端工程化环境&lt;/h2&gt;
&lt;p&gt;  想到react环境的话第一就是create-react-app呗，官方指定脚手架。然而，一个正常的前端开发环境，测试要有吧，生态组件要有吧，CI要有吧，就算不用typescript，起码的ES6要用上吧。仅仅是用上react，只需要在html头引入react库就够了，但是一个能用的前端工程化环境绝对不是一个引入了各种库的html就够了。&lt;/p&gt;
&lt;p&gt;  话是这么说的，但是啥玩意儿都是从简到繁的，所以这里先搭建一个react的基础环境。&lt;/p&gt;
&lt;h2 id=&#34;2-路由网络uitssass&#34;&gt;2 路由，网络，UI，TS，sass&lt;/h2&gt;
&lt;p&gt;  路由使用connected-react-router，网络方面使用redux-thunk和axios，UI用antd(本来用bootstrap，然而好像bootstrap-react并没有很成熟)。然后Typescript也是需要的。connected-react-router和redux-thunk在之前的记录里面提到过了，不多比比。axios就是网络请求库，当fetch用就好。&lt;/p&gt;
&lt;p&gt;  第一个问题出现了，UI库的css不论是antd还是bootstrap的css文件都是没有css module的，当你在index.tsx文件中import css文件会一次性加载所有css。antd官方文档有提供解决方案，&lt;a href=&#34;https://ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE&#34;&gt;antd按需加载&lt;/a&gt;。这里的那个react-app-rewired可以在不eject react-script的情况下更改react-script的webpack配置，好用的一批&amp;hellip;亏我之前不知道，结果eject一堆堆配置看得我脑壳疼。
  然后install typescript，这里有个问题，那就是很多库没有定义过类型信息(比如react)。就需要install @type/react这样的东西，那如果有些东西在npm上面没有类型定义呢，比如我要导入一个svg，本来直接import就好了，但是typescript需要知道svg的类型信息，那就只能自己定义一个svg的类型。
  在typescript里面申明类型信息，src里面建立一个index.d.ts如下写就好了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;reference types=&amp;#34;node&amp;#34; /&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;reference types=&amp;#34;react&amp;#34; /&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/// &amp;lt;reference types=&amp;#34;react-dom&amp;#34; /&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;declare&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;module&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*.svg&amp;#39;&lt;/span&gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;React&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;react&amp;#39;&lt;/span&gt;;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReactComponent&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;React.FunctionComponent&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;React&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SVGProps&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;SVGSVGElement&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;: &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  上面那个三斜杠表示引用项，下面的declare表示定义模块类型信息。这里有点被坑惨了&amp;hellip;.之前eject react-script之后直接run start是会直接can not find module svg，事实上不eject直接run react-script会在react-script里面自动生成一个react-app.d.ts用于定义一些resource的类型，emmm就当学习了&amp;hellip;&amp;hellip;.&lt;br&gt;
  最后是sass，这个简单，脚手架已经配置好了loader，只需要install sass-node就好了，这里sass的npm下载可能很慢，建议cnpm。如果之前的antd有配置过按需加载，安装完node-sass后在sass文件里面也可以直接 @import &amp;ldquo;~antd/dist/antd.css&amp;rdquo;;&lt;/p&gt;
&lt;h2 id=&#34;3-测试&#34;&gt;3 测试&lt;/h2&gt;
&lt;p&gt;  一个工程化的项目测试一定是要的伐，前端测试框架那么多我当然就用现在组里在用的那个jest。CRA(create react app简称，我以后都这么叫好了..)自带有jest，那么咱就安装@types/jest，enzyme，jest-enzyme，enzyme-adapter-react-16(这个包按照react版本来)。&lt;br&gt;
  一般来说，如果是自己整的jest环境，还需要写几个文件去mock 静态资源文件，比如svg，jpg，css。非常开心CRA都自己写好了mock数据的配置文件。然后是enzyme的问题，enzyme想要测试react的话，按照官方文档，我们需要&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;configure&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;enzyme&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Adapter&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;enzyme-adapter-react-16&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;jest-enzyme&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#a6e22e&#34;&gt;configure&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;adapter&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Adapter&lt;/span&gt;() });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这么一个配置项写到指定jest的setupTests文件。然后弄了半天的我发现react-script其实有定义默认的setupTests&amp;hellip;..路径为src/setupTests.ts。也就是说我们只需要在src目录下面新建setupTests.ts文件，然后把以上代码复制进去就够了。其实还是比较建议看一看react-script里面具体有哪些文件是默认可配置的&amp;hellip;&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-81fa98ab577cc4fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;default configure path&#34;&gt;&lt;/p&gt;
&lt;p&gt;  基本一个本地能用的前端就这样了，其实感觉可以称之为boilerplate(算是给出了我认为的前端的比较全面的配置)，等jenkins配好了，基本就是一个完整的工具链实践。现在想想其实还是gitlab好使啊&amp;hellip;.包括agile board和CI它都有的&amp;hellip;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Closure</title>
      <link>https://tommy0121.github.io/post/closure/</link>
      <pubDate>Wed, 07 Aug 2019 12:26:18 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/closure/</guid>
      
        <description>&lt;h2 id=&#34;1-使用场景&#34;&gt;1 使用场景&lt;/h2&gt;
&lt;p&gt;  自己写demo的时候碰到一个问题，我在使用document.addEventListener()的时候，添加的callback必须要传入几个参数。这个问题不大，我可以用闭包的形式这样写&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;listener&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;) =&amp;gt;{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;)  
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是我用的react我需要在componentWillUnMount的时候需要这个eventListener删了，这种返回的function 是个匿名函数是删不掉的。
  这个时候就需要bind()方法了，bind()方法创建一个新的函数，新函数的&lt;strong&gt;this&lt;/strong&gt;，被方法的第一个参数指定，其余参数则作为新函数的参数提供调用。咱可以这样写&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;listener&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;keyListener&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;listener&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;bind&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;);
document.&lt;span style=&#34;color:#a6e22e&#34;&gt;addListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;keydown&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;keyListener&lt;/span&gt;);
document.&lt;span style=&#34;color:#a6e22e&#34;&gt;removeEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;keydown&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;keyListener&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;2-引申及思考&#34;&gt;2 引申及思考&lt;/h2&gt;
&lt;p&gt;  好了，这里涉及到的代码可以引申出去的知识点有下面这几个：this, bind(), call(), apply(), closure。this，bind()，closure不提，为啥会扯到call() apply()呢，因为mdn翻了一下function类型的prototype方法除了toString()就三个，bind(),call(),apply()，顺便了解下没毛病。&lt;/p&gt;
&lt;h3 id=&#34;21-闭包&#34;&gt;2.1 闭包&lt;/h3&gt;
&lt;p&gt;  咱按照《你不知道的JavaScript》的顺序来讲，先讲讲闭包。闭包的外在表现是在定义时的词法作用域外的地方被调用时可以访问定义时的作用域。比如这里的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;listener&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;) =&amp;gt;{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;)
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;)  
  }
}
document.&lt;span style=&#34;color:#a6e22e&#34;&gt;addListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;keydown&amp;#34;&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;listener&lt;/span&gt;());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  当我们keydown事件触发的时候我具体执行的是这样一个匿名函数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;)=&amp;gt;{ &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg2&lt;/span&gt;);&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;);  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  其中e是事件触发时callback传入的参数，而arg2和arg1的值完全是函数定义的时候的变量&amp;hellip;.闭包是个啥东西呢，基本可以认为如果将具体执行函数单独挑出来，发现其中调用了定义时的作用域的变量，那么这就是个闭包&amp;hellip;.所以其实书中认为IIFE并不是个闭包..
  关于闭包我再翻个var带来的闭包老黄历，如下所示&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;body&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ul&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;adf&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;d&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fff&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;zc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;ad&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;li&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;vv&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/li&amp;gt;&lt;/span&gt;

  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/ul&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/body&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;script&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; document.&lt;span style=&#34;color:#a6e22e&#34;&gt;getElementsByTagName&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;li&amp;#34;&lt;/span&gt;);
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, () =&amp;gt; {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;)
    })
  }
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;/script&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这个时候发现无论点的哪个，console出来的都是7，原因是当我们点击调用callback的时候，函数去定义时作用域查找变量i，但是这个时候已经循环结束，i的值一直都是7，所以每次click都是打印的7。以前正确做法是在addEventListener处自己创建一个闭包来存储每次的变量副本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;;
      &lt;span style=&#34;color:#a6e22e&#34;&gt;list&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;].&lt;span style=&#34;color:#a6e22e&#34;&gt;addEventListener&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;, () =&amp;gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;)
      });
    })();
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  现在嘛，只要for的时候i用let关键字来定义就好了&amp;hellip;.事实告诉我再用var我就是傻逼。(再吐个槽，var没有块级作用域真的是个傻逼东西)&lt;/p&gt;
&lt;h3 id=&#34;22-this&#34;&gt;2.2 this&lt;/h3&gt;
&lt;p&gt;  关于this，js的this指向要判断runtime的调用环境，然后再根据代码几种绑定类型判断具体this是个啥。(像我这种java写习惯的一开始碰到这个this真的是蒙了)。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用环境在function中
如果是代码处于严格模式下严格模式则this是undefined，如果不是则指向window(这里有个很坑爹的情况，就是一块代码中严格模式和非严格模式混用&amp;hellip;.最终this的指向取决于写的this的位置是否处于严格模式代码块中&amp;hellip;虽然我觉得我可能用不到这个知识点..)&lt;/li&gt;
&lt;li&gt;调用环境在object中
调用环境在object中this指向的就是object&amp;hellip;书上还特意给了函数作为callback时以及函数以别名形式被调用时的情况，说了一堆this丢失&amp;hellip;..其实都没必要，反正最终看的还是函数执行时环境即可&amp;hellip;..针对这两种情况下面这个例子就很好理解&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;in function&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#75715e&#34;&gt;// should be ’window‘
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;in object&amp;#39;&lt;/span&gt;);
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#75715e&#34;&gt;//should be &amp;#39;obj2&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;();
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;child&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;,
    &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;obj2&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;child&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;使用function.prototype方法手动绑定
这个方法就是js提供了api让自己手动绑定this值呗，就是call apply bind 三个方法，具体这三个方法有啥用，&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function&#34;&gt;MDN&lt;/a&gt;有，后面我也会有记录。&lt;/li&gt;
&lt;li&gt;new 操作符
js 的new操作符是个很神奇的东西，因为它new出来的东西永远是个object&amp;hellip;所以new操作符下的所有this指向的都是new出来的object，例子如下&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);&lt;span style=&#34;color:#75715e&#34;&gt;// 打印出来的是一个名为foo的object...
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这里还要着重说明下arrow function的this，指向的是外层环境的this而不是根据runtime环境判断this，这很关键，&lt;strong&gt;因为一般function需要看执行栈判断，但是arrow function则只需要看你代码的环境&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
      &lt;span style=&#34;color:#75715e&#34;&gt;// 箭头函数的this指向foo
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);
    }, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
  };
  &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){
      &lt;span style=&#34;color:#75715e&#34;&gt;// 一般函数的this要根据调用环境判断，所以这里timeout的callback的this是window
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;);
    }, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
  };
  &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;obj&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;// 2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;3-bind-call-apply&#34;&gt;3 bind call apply&lt;/h2&gt;
&lt;p&gt;  终于是扯到这三个函数了，其实最开始写react的时候发现react在render里面的jsx的onclick绑定component方法有两种写法，但大致就是一种用arrow function一个是在constructor的时候用bind方法。当时云里雾里的，现在看了看js里面的这些概念终于是明白为啥arrow function能用了。click事件的执行环境肯定不在原组件上啦，那这个click的this就应该是根据最终callback执行时环境判定(仔细搜了一下，react的事件其实有一套自己的事件合成，所以其实jsx 里面的 onclick应该是指向最终调用的component的..好吧不是很确定)。那arrow function是可以将this指向代码书写环境，那就可以直接调用component里面的函数，那么bind是个什么吊东西&amp;hellip;..&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;bind()
bind创建返回一个新的函数(继承原函数)，其中bind的第一个参数会作为新函数的this指向，其余参数则会作为参数传入新函数。~~那其实在constructor里面执行bind只是单纯的将当前component绑定到目标方法的this上面&amp;hellip;.为什么会和最终的callback的this绑一起&amp;hellip;这就很费解了。~~这个问题暂时留去给以后看react源码时候想，现在我们专注于这三个function。&lt;/li&gt;
&lt;li&gt;call apply
call apply 都是给函数指定this和参数并&lt;strong&gt;调用&lt;/strong&gt;(bind是返回包装过的函数)，两者唯一区别是apply的参数是作为一个数组apply(this,[argArray])。原函数收到的是一个数组，call则是传入一个参数列表call(this,args1,args2&amp;hellip;.)。原函数收到的是一个个参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后呢，再提一个面试可能问道的问题，也比较现实的问题，如何实现bind()，因为bind()是es5标准，要兼容的话咱得加polyfill，其实&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind&#34;&gt;MDN&lt;/a&gt;上面有来着，而且也推荐了github上面一个实现bind的lib：&lt;a href=&#34;https://github.com/Raynos/function-bind&#34;&gt;function-bind&lt;/a&gt;。要我自己写的话&amp;hellip;其实基本就是用一下call和apply&amp;hellip;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt; Function.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;bind&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;originThis&lt;/span&gt;) {

    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Array.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
    &lt;span style=&#34;color:#75715e&#34;&gt;//这里的这个this就是需要bind的function
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;functionToBind&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;functionBound&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; () {
    &lt;span style=&#34;color:#75715e&#34;&gt;// this instanceof functionBound === true时,说明返回的fBound被当做new的构造函数调用
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;//new 的优先级大于bind，所以这里的this，应该是默认的this
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;finalThis&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;instanceof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;functionBound&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;originThis&lt;/span&gt;;

      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;functionToBind&lt;/span&gt; .&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;finalThis&lt;/span&gt; , &lt;span style=&#34;color:#a6e22e&#34;&gt;args&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;concat&lt;/span&gt;(Array.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;slice&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;)));
    };

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;functionBound&lt;/span&gt; ;
  };
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>Redux Thunk以及简易middleware构建</title>
      <link>https://tommy0121.github.io/post/redux-thunk%E4%BB%A5%E5%8F%8A%E7%AE%80%E6%98%93middleware%E6%9E%84%E5%BB%BA/</link>
      <pubDate>Sun, 30 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tommy0121.github.io/post/redux-thunk%E4%BB%A5%E5%8F%8A%E7%AE%80%E6%98%93middleware%E6%9E%84%E5%BB%BA/</guid>
      
        <description>&lt;p&gt;  咱之前有记录过关于redux的东西。然而就算加上了redux，react依然不能作为一个完整框架使用(其实人家本就只算是个lib&amp;hellip;)是残缺的(对于这点我只能说，还是angular方便- -)。非常需要解决的有两点。&lt;br&gt;
  1、SPA得要有前端路由..。&lt;br&gt;
  2、网络请求放在哪里？(这一点其实官网上面有提过componentDidMount是发送网络请求的好地方原话:&lt;strong&gt;this is a good place to instantiate the network request.&lt;/strong&gt;，然而在componentDidMount里面网络请求一点都不好用..原因是在componentDidMount里面延迟setState会有警告&lt;a href=&#34;https://tommy0121.github.io/post/%E8%81%8A%E5%A4%A9%E6%A1%86%E6%95%88%E6%9E%9C/&#34;&gt;具体参考另外一篇记录&lt;/a&gt;，而且网络请求堆在component里面也是非常的不方便，最好能够将网络请求统一管理起来&amp;hellip;..)&lt;/p&gt;
&lt;h2 id=&#34;1-thunk&#34;&gt;1 thunk&lt;/h2&gt;
&lt;p&gt;  先来回顾一下redux流程..
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-2ca9835d24018374.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;redux.png&#34;&gt;&lt;br&gt;
  在这里咱就发现了，redux有点问题，它只能dispatch一个包含了更新state数据的纯object，它没有办法再dispatch里面处理一些异步逻辑。最简单来讲我希望我发出网络请求的时候有个state更新，在请求失败的时候有个state更新，在请求成功之后有个state更新。&lt;br&gt;
  redux-thunk解决的就是这么一个问题，redux-thunk作为redux的中间件，在action执行之前，会判断传入的action是不是function如果是则将dispatch getState传入该function并执行。代码就几行来着..&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createThunkMiddleware&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;extraArgument&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ({ &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;getState&lt;/span&gt; }) =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt; =&amp;gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;function&amp;#39;&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;getState&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;extraArgument&lt;/span&gt;);
    }

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;);
  };
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thunk&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createThunkMiddleware&lt;/span&gt;();
&lt;span style=&#34;color:#a6e22e&#34;&gt;thunk&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;withExtraArgument&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;createThunkMiddleware&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;thunk&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  所以有了thunk之后我们写异步请求的时候就是这样写的..&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// eslint-disable-next-line no-unused-vars
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetchUsers&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;USERS_URL&lt;/span&gt;;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;) =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;USERS_REQUEST&lt;/span&gt; });
    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt; {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;apiClient&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;();
      &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;USERS_RECEIVE&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; });
    } &lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;) {
      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [{
        &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mock name&amp;#39;&lt;/span&gt;,
        &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mock id&amp;#39;&lt;/span&gt;,
        &lt;span style=&#34;color:#a6e22e&#34;&gt;desc&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;mock desc&amp;#39;&lt;/span&gt;,
      }];
      &lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;({ &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;USERS_RECEIVE&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; });
    }
  };
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这里这个fetchUsers返回的是一个function，然后thunk将其拦截下来，将dispatch传入并执行这个function。&lt;br&gt;
  网络请求的问题解决了，那单页面应用的路由问题咋整呢？我自己在网上找的时候一片片的全是react-router。然而react-router所有的路由跳转都自己包装了一遍，我需要从react-router-dom里面引用组件来跳转。如果我想在redux的action里面进行路由跳转&amp;hellip;又是只能挠挠头了&amp;hellip;.&lt;/p&gt;
&lt;h2 id=&#34;2-middleware的应用&#34;&gt;2 middleWare的应用&lt;/h2&gt;
&lt;p&gt;  到了项目上面发现居然用的不是这个&amp;hellip;咱可以不用react-router-dom，所有的路由跳转都是一句话history.push()。说实话这个看上去比react-router好使多了，咱终于是能在redux里面跳转路由了。&lt;br&gt;
  那么这东西咋用呢，其实这个在react-router的doc里面有提及过&amp;hellip;在&lt;a href=&#34;https://reacttraining.com/react-router/web/guides/redux-integration&#34;&gt;https://reacttraining.com/react-router/web/guides/redux-integration&lt;/a&gt;是一个叫&lt;a href=&#34;https://github.com/supasate/connected-react-router&#34;&gt;Connected React Router&lt;/a&gt;的东西，也没啥好说的看看文档就会了。主要还是想说一下项目里面别人搞得一个middleWare。&lt;br&gt;
  是这样的，现在做的东西虽然流程上面有点复杂，但是总体上来说是类似于银行自助服务机上面的那样的东西，就是走流程性的东西。本来以我自己的做法的话可能就是在页面上面的next button里面判断一下条件决定后面应该进入哪个页面，然后再调用history push去跳转页面。&lt;br&gt;
  但是这样会有个问题大量的判断逻辑堆在了component里面。会显得组件非常的臃肿，代码可能就长成这样&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;handleNext&lt;/span&gt;(){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;conditionA&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;props&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;reducer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;)){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;history&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/aa&amp;#39;&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;conditionB&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;props&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;reducer&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;)){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;history&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;push&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/BB&amp;#39;&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#75715e&#34;&gt;// and so on
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  但是我也不知道该咋改啊&amp;hellip;.然后我没纠结多久，有人写了个middleWare去解决(虽然后面这个东西越写越臃肿..但是思路确实是学到了)&amp;hellip;&lt;br&gt;
  首先，我们先收集到所有情况的路由跳转。然后根据这个建立一个url跳转的map。类似于这样的object&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;urlMaps&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;currentUrl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/home&amp;#39;&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;nextUrls&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
      [
        {
          &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/step1&amp;#39;&lt;/span&gt;,
          &lt;span style=&#34;color:#a6e22e&#34;&gt;condition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;)=&amp;gt;{}
        },
        {
          &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/b&amp;#39;&lt;/span&gt;,
          &lt;span style=&#34;color:#a6e22e&#34;&gt;condition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;)=&amp;gt;{}
        },
      ]&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;，&lt;/span&gt;
     &lt;span style=&#34;color:#a6e22e&#34;&gt;enterLog&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;)=&amp;gt;{}
    },
    {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;currentUrl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/step1&amp;#39;&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;nextUrls&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
      [
        {
          &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/a&amp;#39;&lt;/span&gt;,
          &lt;span style=&#34;color:#a6e22e&#34;&gt;condition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;)=&amp;gt;{}
        },
        {
          &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/b&amp;#39;&lt;/span&gt;,
          &lt;span style=&#34;color:#a6e22e&#34;&gt;condition&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;)=&amp;gt;{}
        },
      ],
         &lt;span style=&#34;color:#a6e22e&#34;&gt;enterLog&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;)=&amp;gt;{}
    }
  ]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  然后再暴露出一个专门控制路由的方法来。根据当前的路由(由于用的是connected-react-router，reducer里面有保存当前页面的路由的，在 state.router.location.pathname里面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-b6fcb6243baa439a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;W}8FL7OYM7DZPT8}727X@G4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;获得urlMap，然后根据urlMap中的condition来决定下一个页面的路由。&lt;br&gt;
  路由控制是给它整一块儿了，顺手把一些进入页面就需要干的事情给他干了，比如我每个页面的每一次进入都需要向后台发一次请求，记录页面的进入(后台需要统计每个页面的进入次数用于分析)，其实也类似于打log的存在了。&lt;br&gt;
  这个时候咱整一个middleWare来拦截路由变化(connected-react-router每次路由变化的时候都会dispatch一个type为Location_change的action，拦截这个action即可)。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;logMiddleWare&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt; =&amp;gt; {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;switch&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LOCATION_CHANGE&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
      &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;currentUrl&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;getMapItem&lt;/span&gt;(
        &lt;span style=&#34;color:#a6e22e&#34;&gt;urlMaps&lt;/span&gt; ,
        &lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;payload&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;location&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;pathname&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//这个payload就是要更改的数据
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;      );
      &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;currentUrl&lt;/span&gt;) {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;enterLog&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;currentUrl&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;store&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getState&lt;/span&gt;()));
      }
      &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;next&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;action&lt;/span&gt;);
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;  emmm项目上用到的redux基本上就这样了&amp;hellip;该记录的都记录下来了。其实一开始思路想到建立一个urlMap的时候会想到一旦页面多起来了咋整。但是现在的项目是这样的，每一个flow都是一个单独的SPA，所有的状态都是单独管理互不干扰的，就算我有好几页，一页六七个flow，我也只需要专心眼前的flow就完事儿了。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>谈谈git Flow</title>
      <link>https://tommy0121.github.io/post/%E8%B0%88%E8%B0%88git-flow/</link>
      <pubDate>Mon, 24 Jun 2019 14:27:06 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/%E8%B0%88%E8%B0%88git-flow/</guid>
      
        <description>&lt;p&gt;  git不提了，版本管理工具写过代码的应该都知道&amp;hellip;.主要记一下咱现在用的git flow(主要感觉现在的git flow还是蛮规范的&amp;hellip;有必要记录一下&amp;hellip;)&lt;/p&gt;
&lt;p&gt;  首先呢，现在的flow是适用于现在的敏捷开发上。因为敏捷开发分task，所以很多branch都是按照所做的task来命名，commit的也是按照task名字来写的..&lt;/p&gt;
&lt;p&gt;  现在的git flow首先根据自己在jira接到的task自己从master(这里其实不怎么好，因为我们没有分production，QA，test，dev的branch，做好的东西直接往master扔，之前呆的一个项目组这点比较好，首先代码进的dev分支，然后部署dev环境，然后自己开发测测没问题再去merge到test分支&amp;hellip;)分一个branch出来，branch名字根据自己做的task来命名，然后做好之后git rebase，将所有commit记录合并为一个记录并且merge到master分支，然后github提个pull request让人来review一下&amp;hellip;&lt;/p&gt;
&lt;p&gt;  其他的都没啥问题，主要是commit将记录合并为一个记录一开始我是蒙蔽的&amp;hellip;问了下才知道git rebase 然后就好了。&lt;/p&gt;
&lt;p&gt;  问题来了，git rebase具体有啥用呢，咋用呢&amp;hellip;.首先咱先去git book看看git rebase在vcs里面的作用&lt;a href=&#34;http://gitbook.liuhui998.com/4_2.html&#34;&gt;gitbook_rebase&lt;/a&gt;。具体作用其实就是让分支合并的时候使所有提交记录变为一条直线。而不是像merge一样分叉的厉害。&lt;/p&gt;
&lt;p&gt;  咱先来看看git merge 和git rebase的区别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-16/4706ce03.png&#34; alt=&#34;rebase&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://123.207.87.254:3999/static/uploads/images/2020-04-16/0178aef1.png&#34; alt=&#34;merge&#34;&gt;&lt;br&gt;
  咱能看到本来merge的话，git log将记录以时间排序，但是用rebase之后，feature branch提交的记录就全部在master的commit之后了&amp;hellip;总之就是方便代码管理&amp;hellip;&lt;/p&gt;
&lt;p&gt;  然后就是commit提交记录合并为一条。其实也很简单，就在rebase 后面加个-i，就是执行squash。具体咋用百度就知道了&amp;hellip;懒得再去搞了&amp;hellip;&lt;/p&gt;
&lt;p&gt;  总之就是用rebase对于代码控制很方便就是了&amp;hellip;想想多人合作的时候，可以很方便的回退到某个feature上，也可以控制无意义的commit&amp;hellip;&amp;hellip;总之很有用就完事儿了&amp;hellip;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Jest React Test</title>
      <link>https://tommy0121.github.io/post/jest-react-test/</link>
      <pubDate>Mon, 10 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tommy0121.github.io/post/jest-react-test/</guid>
      
        <description>&lt;p&gt;  首先呢，咱这里要求测试覆盖率要有90以上，UI也要测。原本用的mocha测试框架，然后由于有大量的UI需要测试，导致了测试代码比原本的代码还要多(太尼玛真实了..)。然后就换了框架，用jest&amp;hellip;还真别说，jest的snapshot是真滴好使，只要mapToSnapShot一个方法就能cover大部分的UI。&lt;/p&gt;
&lt;h2 id=&#34;1测试不同分辨率下不同的表现&#34;&gt;1：测试不同分辨率下不同的表现&lt;/h2&gt;
&lt;p&gt;  然而，jest也不是万能的，为了适配分辨率，用mediaquery写了好几套的css，snapshot只能测到某一套css。还有两套的是测不到的(以我个人感觉，测不到就测不到呗，奈何测试覆盖率会低下来哦)&amp;hellip;所以这里就记录第一个tips，用jest测试不同分辨率。&lt;/p&gt;
&lt;p&gt;  首先呢，测UI其实只要html上面的className是我们想要的，具体长啥样我们是不管的。然后media query不同的分辨率下className不同，是根据body里面的clientWidth来判断的。&lt;/p&gt;
&lt;p&gt;  那么问题简单了，jest啊mocha啊其实算是个js的运行容器，类似于document.body这样的全局属性是存在的，但是它们没有值(直接去获得document.body.clientWidth是拿不到的，因为在jest里面有body，但是body里面没有clientWidth)，所以我们用Object.defineProperty(document.body, &amp;lsquo;clientWidth&amp;rsquo;, { value: 768 ,configurable: true,});来给jest添加全局clientWidth就可以了(configurable记得要加上，不然不能redefine property)。&lt;/p&gt;
&lt;h2 id=&#34;2单独组件不要使用redux&#34;&gt;2：单独组件不要使用redux&lt;/h2&gt;
&lt;p&gt;  = =这个经验真的是血的教训&amp;hellip;.&lt;/p&gt;
&lt;p&gt;  一般来说呢，测试redux包裹的组件呢，就是直接把使用connect之前的组件export出来，然后直接测。因为如果引用的是connect的那个组件，你就需要在测试里面同样的加上provider父组件。而且好多东西你完全测不了(忘了当时遇到啥东西测不了，反正最后还是选择不引用connect那个组件解决的)&amp;hellip;.如图：&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-a6179aa98082f792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;example&#34;&gt;&lt;br&gt;
  后来碰到一个情况，我特么手贱在某个component里面用了redux，直接导致所有用到该component的container直接测试failed&amp;hellip;.在shallow component的时候直接就报错，connect过的组件需要provider&amp;hellip;&amp;hellip;然后就只能默默的把东西都改回来&amp;hellip;.&lt;/p&gt;
&lt;p&gt;  那么咱为啥要在组件里面写redux呢，因为某个组件就固定要用到redux的某两个数据&amp;hellip;参考前面的文章..&lt;a href=&#34;https://tommy0121.github.io/post/%E8%81%8A%E5%A4%A9%E6%A1%86%E6%95%88%E6%9E%9C/&#34;&gt;聊天框动画效果&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>聊天框效果</title>
      <link>https://tommy0121.github.io/post/%E8%81%8A%E5%A4%A9%E6%A1%86%E6%95%88%E6%9E%9C/</link>
      <pubDate>Mon, 06 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tommy0121.github.io/post/%E8%81%8A%E5%A4%A9%E6%A1%86%E6%95%88%E6%9E%9C/</guid>
      
        <description>&lt;h2 id=&#34;1需求&#34;&gt;1：需求&lt;/h2&gt;
&lt;p&gt;  原需求是要做个聊天框效果，但是聊天框是从下到上的..原本一般的从上到下聊天框就很简单，我只要把动画效果封装到组件里面，然后延迟给数组添加数据就可以了，类似如下这样&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-5273856bb8dea83b.gif?imageMogr2/auto-orient/strip&#34; alt=&#34;animation.gif&#34;&gt;&lt;br&gt;
  但是需求咋可能这么简单呢&amp;hellip;.我最终需要的效果长这样&amp;hellip;.不仅如此，这个聊天框组件距离页面的header的margin是固定的，那么聊天框整个组件一开始的初始位置就应该是聊天框组件的高度加上某个固定的margin-top。&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-dc5008098b032bb9.gif?imageMogr2/auto-orient/strip&#34; alt=&#34;requirement.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;  要做聊天框上移效果，第一次上移的距离是loading动画的距离，第二次上移的距离是下个聊天框高度减去loading高度的距离，loading动画高度固定可写死，但是下个聊天框的高度就免不了需要用api获得高度。
  反正就是乱七八糟的一大堆属性需要用js动态的获得。组件的初始位置的margin-top还好，在didMount方法里面直接设置就完事儿了。但是css的动画定义是hard code，所以无法直接动态设置css动画的移动高度。&lt;br&gt;
  解决方案：&lt;br&gt;
  1、动态添加css。在上移高度计算好之后在document上面动态添加css样式&lt;br&gt;
  2、使用原生的js动画，可用的API有requestAnimaionFrame，和setInterval，区别是requestAnimationFrame是固定60帧移动，setInterval是可设置移动帧数。自己写动画太费时间，所以最后是使用了anime.js来做动画效果。&lt;/p&gt;
&lt;p&gt;  使用的react，根据react生命周期，需要在render之后才能dom的确切高度，使用ref获得节点，在componentDidMount里面获得节点高度进行计算。计算出div的margin-top和以及需要的anime。&lt;/p&gt;
&lt;h2 id=&#34;2问题&#34;&gt;2：问题&lt;/h2&gt;
&lt;h3 id=&#34;31-html高度问题&#34;&gt;3.1 html高度问题&lt;/h3&gt;
&lt;p&gt;  问题来了，在componentDidMount获得的高度是未应用css时，原生html的高度，即无法获得css渲染后的dom高度。
  问题所在：这是因为webpack在style-loader, less-loader, css-loader 加入sourceMap打包的时候先运行了生成dom的js，再通过js引入css 。去除即可（其实找了个plugin，mini-css-extract-plugin这个也可以解决先运行js再运行css的问题的）&lt;/p&gt;
&lt;h2 id=&#34;32还是html高度问题&#34;&gt;3.2：还是html高度问题&lt;/h2&gt;
&lt;p&gt;  即使是去除了source-map获得的dom高度依然是有问题的。原因在于，使用的字体是谷歌的第三方字体，而第三方字体渲染的机制如下：&lt;/p&gt;
&lt;p&gt;   第三方字体加载未完成之前，所有的字体样式的css并不应用，同时使用浏览器本地字体库代替第三方字体，当第三方字体加载成功后，第三方字体会替代本地字体。&lt;/p&gt;
&lt;p&gt;   很不幸，debug发现js执行到获取dom高度的时候第三方字体并没有加载成功，所以获取到dom的高度是本地字体渲染时的高度，与最终呈现的高度有所误差。最终找到一个fontfaceobserver的插件使用，插件会观察制定的字体加载情况，提供了一个加载成功的promise，将所有计算以及获取代码放到这个promise中即可(目前不知道直接下载font是不是有效的解决方案，主要不知道怎么才能把font文件放在服务器上= =)。&lt;/p&gt;
&lt;h2 id=&#34;33组件生命周期&#34;&gt;3.3：组件生命周期&lt;/h2&gt;
&lt;p&gt;   本以为到此为止，运行之后看见控制台有抛出一个警告。大意是，不要在componentDidMount使用延时的setState()。因为可能会出现promise未返回，或者setTimeout时间未到，component就已经Unmount了，这个时候执行setState去设置div的margin显然是不行的。&lt;/p&gt;
&lt;p&gt;   解决方案：动态计算出来的margin值不放在state里面，而是存储在redux中，然后作为props传入组件，在promise里面调用某个action，改变margin值这样的话，即使组件已经unmount了，更改redux值也不会有什么问题。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;   至此，动画效果问题基本解决。遗留的唯一一个问题是可不可以通过下载font把fontfaceobserver干掉&amp;hellip;.但是我这里又没办法去弄服务器，就很烦。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Promise Async</title>
      <link>https://tommy0121.github.io/post/promise-async/</link>
      <pubDate>Mon, 29 Apr 2019 13:41:10 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/promise-async/</guid>
      
        <description>&lt;p&gt;  首先声明想要记录这个东西上下文。在之前只用过fetch和ajax，就是网络请求的时候一般都是fetch().then().catch()这样的promise链式调用，然而项目里面看见的api接口访问长这样&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;apiCaller&lt;/span&gt;(){ &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;)}&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;；&lt;/span&gt;

&lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;aplClient&lt;/span&gt;(){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;apiCaller&lt;/span&gt;();
  }&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;){
    &lt;span style=&#34;color:#a6e22e&#34;&gt;doErrorExcution&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;);
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  try catch好说，啥语言都有的语法，但是这个await是个啥&amp;hellip;.8说了，查资料去&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;async-await&#34;&gt;async await&lt;/h2&gt;
&lt;p&gt;  首先，async和await使用方法。await必须在async方法内，当执行到await时候，await后面的语句会在await语句执行完之后执行。还有就是await 执行完赋予变量是Promise.resolve()里面的值，如果有error则直接进catch。&lt;br&gt;
  咱先搞个demo试试，首先我不加await关键字&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterOneSec&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise(&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt; =&amp;gt; {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;);
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;1 sec&amp;#39;&lt;/span&gt;);
      }, &lt;span style=&#34;color:#ae81ff&#34;&gt;1000&lt;/span&gt;);
    })
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterTwoSec&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise(&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt; =&amp;gt; {
      &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2&amp;#39;&lt;/span&gt;);
        &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2 sec&amp;#39;&lt;/span&gt;);
      }, &lt;span style=&#34;color:#ae81ff&#34;&gt;2000&lt;/span&gt;);
    })
  };
 &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterTwoSec&lt;/span&gt;();
    &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterOneSec&lt;/span&gt;();
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt;());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  得到的结果是先打印了2再打印1。删掉await之后，就先打印了1,再打印2。就不放置结果了&amp;hellip;.&lt;br&gt;
  await是这样的，那么async这个关键字表示了啥啊，首先async这个方法表示函数是异步的(尼玛的，废话)&amp;hellip;其次，async修饰的函数返回的是一个promise&amp;hellip;上述example函数打印出来长这样。&lt;br&gt;
&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/6229530-b0578af11804be1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;example&#34;&gt;&lt;/p&gt;
&lt;p&gt;  正常来说我这个函数没有定义返回值，我打印出来的值应该是个undefined。然而打印出来一个Promise&amp;hellip;而且在函数内如果有await的话，那么返回的promise在await执行完毕之前状态为pending，如果没有await的话，返回的是一个状态确定的promise。如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterTwoSec&lt;/span&gt;();
    &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterOneSec&lt;/span&gt;();
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt;());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这里的example相当于返回的Promise.resolve(undefined)。所以这个特性有啥用呢&amp;hellip;俺也不知道，俺也没碰到&amp;hellip;.咱只知道下面这种情况有问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Ids&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;( &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt; =&amp;gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  网上比较一致的说法是，当你需要某个数组逐步执行的时候，以下写法是错的&amp;hellip;.为啥呢，因为await只会阻塞map里面callback，但是并不会阻塞map函数，所以当map结束之后，并不能保证我所有阻塞函数都完成了，正确的要咋整呢。那就要看promise了呀，如下所示&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; () =&amp;gt;{
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;promises&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Ids&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;map&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;id&lt;/span&gt;))
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; Promise.&lt;span style=&#34;color:#a6e22e&#34;&gt;all&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;promises&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  辣么，接下来就讲讲关于Promise的东西。&lt;/p&gt;
&lt;h2 id=&#34;promise&#34;&gt;Promise&lt;/h2&gt;
&lt;p&gt;  说到Promise，其实最开始知道Promise是因为实习的时候用angular，然后官方tutorial直接使用的fetch。然后就从原本的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ajax&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;success&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){};
  &lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;() {};
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;演变成了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fetch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;response&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;()).&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteData&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;)).&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  那么，Promise咋用呢，上面哪两个函数其实差不多了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;promise1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;reject&lt;/span&gt;) =&amp;gt; {
&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;);
  }, &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;);
});
&lt;span style=&#34;color:#a6e22e&#34;&gt;promise1&lt;/span&gt;
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; =&amp;gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;); &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;})
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;))
  .&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这里面会在&lt;strong&gt;resolve执行之后执行then&lt;/strong&gt;方法，并且传入resolve的参数，会作为then的callBack的参数(所以这里then里面的data就是&amp;rsquo;foo&#39;了)，同时&lt;strong&gt;then()也会返回一个Promise&lt;/strong&gt;，像这里的return data.length，其实返回的是一个Promise.resolve(data.length)。&lt;br&gt;
  所以呢，data.length又会作为参数传到下一个then(这里的then里面的length就是foo的length 等于 3)。而&lt;strong&gt;catch方法在被reject的时候调用&lt;/strong&gt;。如果出现这样的返回，就进的catch方法，如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;promise1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Promise((&lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;reject&lt;/span&gt;) =&amp;gt; {
&lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;resolve&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;foo&amp;#39;&lt;/span&gt;);
  }, &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;);
});
&lt;span style=&#34;color:#a6e22e&#34;&gt;promise1&lt;/span&gt;
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; =&amp;gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;); &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;})
  .&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt; =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;length&lt;/span&gt;))
  .&lt;span style=&#34;color:#66d9ef&#34;&gt;catch&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; =&amp;gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  自己运行一下就可以发现在第一个then中出现error之后不执行第二个then，直接执行了catch。&lt;br&gt;
  那么问题又来了，Promise和async/await有啥关系呢&amp;hellip;事实上，async/await是generator和promise的一个语法糖。如下所示(其实没用到过generator..所以不知道这玩意儿有啥用)。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterTwoSec&lt;/span&gt;();
    &lt;span style=&#34;color:#a6e22e&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterOneSec&lt;/span&gt;();
  }
&lt;span style=&#34;color:#75715e&#34;&gt;// 等价于
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;async&lt;/span&gt; () =&amp;gt; {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterTwoSec&lt;/span&gt;().&lt;span style=&#34;color:#a6e22e&#34;&gt;then&lt;/span&gt;(() =&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;excuteAfterOneSec&lt;/span&gt;());
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;为什么&#34;&gt;为什么&lt;/h2&gt;
&lt;p&gt;  之前刚刚接触promise的时候好奇过一段时间，原本用ajax之类的方法，然后在访问接口之后执行回调函数，已经是很方便了呀，我为啥要用promise，还有现在的这个async/await？&lt;br&gt;
  我特么现在终于是知道了，当我需要访问三个接口，我需要三个接口全通之后再进行操作(这样的设计是很多的&amp;hellip;.)我如果用回调函数的话就会陷入回调地狱..&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ajax&lt;/span&gt;({
  &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;firstUrl&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;success&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;() =&amp;gt;{
    &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ajax&lt;/span&gt;({
      &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;secondUrl&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;,
      &lt;span style=&#34;color:#a6e22e&#34;&gt;success&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;() =&amp;gt; {
        &lt;span style=&#34;color:#a6e22e&#34;&gt;$&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ajax&lt;/span&gt;({
          &lt;span style=&#34;color:#a6e22e&#34;&gt;url&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;thirdUrl&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;,
          &lt;span style=&#34;color:#a6e22e&#34;&gt;success&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;() =&amp;gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;finalExcute&lt;/span&gt;()} ,
          &lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;()=&amp;gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;)}
        })
      }
     &lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;()=&amp;gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;)}
    })
  }
  &lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;) =&amp;gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt;)}
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  不说有多难看，我即使接口方面没有依赖我依然必须顺序执行&amp;hellip;要是接口响应很慢，一个加载等一年？要是碰到上面那个需要十个接口全部访问之后再执行的功能，画面太美不敢看&amp;hellip;&amp;hellip;&lt;br&gt;
  针对于这种写法，对于没有接口返回数据依赖的接口promise完全可以用Promise.All解决回调地狱，而且人家还可以用catch来统一处理异常，多个接口访问后执行的实现也更加优雅有效率，而且链式调用用这也比回调函数舒服。&lt;br&gt;
  async/await最爽了，至少在代码层面上看着非常的清爽，避免回调，用try catch处理异常(在这之前写js我根本用不到try catch这个语法的)&amp;hellip;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
</description>
      
    </item>
    
    <item>
      <title>React基础优化</title>
      <link>https://tommy0121.github.io/post/react%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 29 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://tommy0121.github.io/post/react%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96/</guid>
      
        <description>&lt;p&gt;  首先声明写这篇文章的上下文：其实就是项目中碰到了很好奇&amp;hellip;.&lt;/p&gt;
&lt;h2 id=&#34;list和key&#34;&gt;list和key&lt;/h2&gt;
&lt;p&gt;  React的初学者一开始一定会有一个疑问：我在jsx里面用了循环列出来的标签为什么就一定要我加个key的属性呢，这玩意儿有啥用呢&amp;hellip;&amp;hellip;.我也碰到了，也很好奇，于是跑到react官网看，在&lt;a href=&#34;https://reactjs.org/docs/reconciliation.html&#34;&gt;Reconciliation&lt;/a&gt;发现key属性是Virtual DOM更改后，前后比较的一个标识属性。如果没有key属性的话&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Duke&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Villanova&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;

&amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Connecticut&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Duke&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
  &amp;lt;&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;Villanova&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;li&lt;/span&gt;&amp;gt;
&amp;lt;/&lt;span style=&#34;color:#f92672&#34;&gt;ul&lt;/span&gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;类似于这样的更改情况，所有的子节点都会被重新生成，而不是保留后两个节点插入第一个节点。具体原理参考另一篇&lt;a href=&#34;https://tommy0121.github.io/post/diff/&#34;&gt;diff&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  在这之外，官网上面的&lt;a href=&#34;https://reactjs.org/docs/lists-and-keys.html#keys&#34;&gt;Lists and Keys&lt;/a&gt;这一章有说不推荐使用数组的index为key，一方面如果数组头有更改，就会出现重新生成所有节点的情况，另一方面，使用index为key会有风险。&lt;/p&gt;
&lt;p&gt;  具体是啥风险，我好奇的点进&lt;a href=&#34;https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318&#34;&gt;文章&lt;/a&gt;看了一下&amp;hellip;尼玛里面的例子在更新view的时候同时使用dom操作和react的setState方式&amp;hellip;妈的吓我一跳，我写的东西里面一大堆用index来当作key的&amp;hellip;不得不说发现这个问题的人，真的是个小天才。UI的更新操作react和原生dom操作混用&amp;hellip;咋想的&amp;hellip;&lt;/p&gt;
&lt;h2 id=&#34;functional-component&#34;&gt;Functional Component&lt;/h2&gt;
&lt;p&gt;  functional component就是无状态组件，整个组件里面只有一个render()函数，不继承Component里面的生命周期，同时也不能操作State。就单纯的一个展示性的组件，类似于Button啊，ListItem啊之类的非常底部的组件使用functional component就ok了。&lt;/p&gt;
&lt;h2 id=&#34;暂时不知道自己算没算用过的方法&#34;&gt;暂时不知道自己算没算用过的方法&lt;/h2&gt;
&lt;p&gt;  在官网的&lt;a href=&#34;https://reactjs.org/docs/optimizing-performance.html&#34;&gt;Optimizing Performance&lt;/a&gt;一章里面，开头讲的就是用webpack的product mode，这个东西的话，自己虽然用webpack自己搭了个react的环境，development mode和product mode也分开了，但毕竟只是个玩具。&lt;/p&gt;
&lt;p&gt;  不过其实这些东西也自己玩玩就完事儿了，真的要用，直接create-react-app就完事了(现在项目就是，自己搭的环境发现不好使，项目做做一半换脚手架&amp;hellip;..)。&lt;/p&gt;
&lt;h2 id=&#34;看到但是没用过的方法及思路&#34;&gt;看到但是没用过的方法及思路&lt;/h2&gt;
&lt;p&gt;  PureComponent 加上 Not Mutating Data，pureComponent会在shouldComponentUpdate的时候自动检查state和props有没有改变，如果没有改变就return false阻止视图更新。但是有个问题是，PureComponent只是一层浅比较，比较了新旧的内存地址，并没有比较内容。所以需要Not Mutating Data。&lt;/p&gt;
&lt;p&gt;  那么，Not Mutating Data这玩意儿咋用呢，其实很简单&amp;hellip;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setState&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; =&amp;gt; ({
    &lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; [...&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;words&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;newValue&amp;#39;&lt;/span&gt;],
  }));
&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;setState&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt; =&amp;gt; ({
    &lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; {...&lt;span style=&#34;color:#a6e22e&#34;&gt;state&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;key&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;map&amp;#39;&lt;/span&gt;},
  }));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  在setState和setProps用es6的这个三个点的spread syntax可以避免(虽然之前并不知道这样写有啥好处，但是已经习惯这种写法了&amp;hellip;.顺便setState是异步的这点也搞得我脑壳痛)。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;  总结一哈，其实简易的优化思路就俩，一个是打包工具的优化，另外就是减少component render的次数，其实就是在update 方法里面做文章，把可以不update的情况给拦截了就好了。
  再复杂的优化应该是搞两个react的devtool，查看生命周期的耗时，然后优化自己代码了&amp;hellip;不过目前搞得这些东西似乎都用不到来着&amp;hellip;..&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Jsx Virtual Dom</title>
      <link>https://tommy0121.github.io/post/jsx-virtual-dom/</link>
      <pubDate>Sun, 28 Apr 2019 13:17:36 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/jsx-virtual-dom/</guid>
      
        <description>&lt;p&gt;  换了项目组，用react做东西也有段时间了，是时候记录一下学习使用中的遇到的一些问题。&lt;/p&gt;
&lt;h2 id=&#34;jsx&#34;&gt;jsx&lt;/h2&gt;
&lt;p&gt;  首先，最开始使用react就有的疑惑，render()函数里面return的很像html又不是html的东西是啥？react官网上面告诉我们这东西叫做jsx，并且推荐我们使用jsx来描述UI(其实react中也不大可能用其他方式来描述了吧..)。所以呢是事实上render()里面return的其实不是原生的html，而是react团队设计的一个描述语言。&lt;/p&gt;
&lt;p&gt;  但是又有一点很怪，我为啥不设计的更加贴近html，jsx里面所要传递的所有props都是小驼峰形式，即使是类似于margin-top之类，原生的html的属性，也要用marginTop来指定。&lt;/p&gt;
&lt;p&gt;  其实呢，jsx是类xml语法的的JavaScript扩展本质上，jsx是React.createElement(component, props, &amp;hellip;children)的语法糖。component满足React.Component或者ReactHtml的定义的类型(typescript 中会有@types/react可以在这里面查看)，props是一个object，不用说children肯定是close tag里面的子组件。&lt;/p&gt;
&lt;p&gt;  这下好说了，既然jsx的props本质上该是个object，那object里面的属性就该是小驼峰命名，而且html里面的class属性在JavaScript里面是保留字，就变成了className了。如下写法可能更直观一点&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;render&lt;/span&gt;(){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;props&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#a6e22e&#34;&gt;props1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;props2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;value2&lt;/span&gt;}
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;Mycomponent&lt;/span&gt; {...&lt;span style=&#34;color:#a6e22e&#34;&gt;props&lt;/span&gt;}&lt;span style=&#34;color:#f92672&#34;&gt;/&amp;gt;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  当然了，为了不让新手一开始就迷惑，最开始的tutorial肯定不可能是这么写的。&lt;/p&gt;
&lt;h2 id=&#34;virtual-dom&#34;&gt;virtual dom&lt;/h2&gt;
&lt;p&gt;  好了，第一个疑惑解决，第二个问题是，我为啥不是直接return的html，然后里面内置一些模板语法，就像以前的theamleaf，angular.js一样，完全够用啊，没必要就搞个jsx。&lt;/p&gt;
&lt;p&gt;  因为在react设计里面，有个叫virtual dom的东西介于代码和真实dom之间。virtual dom作为UI描述存于内存，真实dom根据virtual dom描述生成。每次数据更新的后重新update virtual dom并与上一次的virtual dom比较，批量更新变化的部分。&lt;/p&gt;
&lt;p&gt;  淦，那为啥又要搞个virtual dom？&lt;/p&gt;
&lt;p&gt;  网上有很多说法是，直接操作dom的开销大，相比之下virtual dom快。但是我觉得最大的好处应该是与底层解耦，与底层解耦之后，就可以跨平台。&lt;/p&gt;
&lt;p&gt;  virtual dom是对于UI的描述应该是属于元数据，最终生成啥平台的UI完全是不知道的，于是就有了react-native跨平台了。&lt;/p&gt;
&lt;p&gt;  最后在浏览器中，virtual dom的优化工作以及原理再以下文章中&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions&#34;&gt;diff&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>Es6 Class</title>
      <link>https://tommy0121.github.io/post/es6-class/</link>
      <pubDate>Wed, 24 Apr 2019 11:25:22 +0800</pubDate>
      
      <guid>https://tommy0121.github.io/post/es6-class/</guid>
      
        <description>&lt;p&gt;  用jest写react的测试的时候有出现一个问题，就是组件中有用到anime.js来制作动画(为啥不用CSSTransition，因为这玩意貌似满足不了需求，也可能是我太菜了..)，结果在jest执行到anime.js的某个方法后卡住(现在想想其实是一直不输出code coverage，可能是Istanbul的问题..)。&lt;/p&gt;
&lt;p&gt;  后来呢就决定绕过所有anime.js方法。具体是怎么做的呢，首先因为anime.js是直接操作dom的，所以anime.js的所有功能都写在了componentDidMount里面，所以在测试的时候在beforeEach里面添了这么一行&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;MyComponent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;componentDidMount&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这么一来，在测试componentDidMount的时候就是啥也没执行了。看到这里，应该就很清楚，js里面的class其实本质上就是一个function，在class里面定义一个成员方法大致等于&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;MyFunction&lt;/span&gt;(){}
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt;(){}

&lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{
  &lt;span style=&#34;color:#a6e22e&#34;&gt;constructor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MyClass&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;MyFunction&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(){}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  到这里还没结束，基础不牢固的我(得找个时候去看看犀牛书啥的..)又开始很奇怪了：为啥这里要用function来模拟class呢？而且function在js里面到底算是一种什么样的结构，js的基本类型里面可没有function。&lt;/p&gt;
&lt;p&gt;  在尝试使用object来模仿class时，发现object是没有构造函数的，而直接使用const a = {}会直接获得一个object的实例，也就是说用object来声明一个类是不可能的，因为获得的永远是一个实例。如果非要用object来模拟class，就只能使用工厂模式，定义一个方法，传入必要参数返回一个object。具体形式如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;classFactory&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt;){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;object&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;,
  &lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;description&lt;/span&gt;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;object&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  这样的方法怎么能叫做class？它甚至无法做到继承。所以目光又转向了function。那么function到底是个啥玩意儿呢？&lt;br&gt;
  js里面在基本类型之外还有一大把的内置对象，其中有个内置对象是Function，而所有定义的function都是Function对象的实例。所以以下两种写法其实作用一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;){
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sum&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; Function(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;a&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;b&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;return a + b&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  至于Function的对象的特性啥的，建议看&lt;a href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions&#34;&gt;MDN&lt;/a&gt;。&lt;br&gt;
  重点来了，如何使用function来模拟一个class并且能让他可以继承呢？现在的我已经是看过一点原型了，所以自己的第一想法是张这样的&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;) {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDesc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`Myname is &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;;
   }
   &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getName&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;;
   }
 }


&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Male&lt;/span&gt;(){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;);
   &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;gender&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;male&amp;#39;&lt;/span&gt;;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDesc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`Myname is &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; and I&amp;#39;m &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;gender&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;;
   }
}

&lt;span style=&#34;color:#a6e22e&#34;&gt;Male&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;people&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MaleStudent&lt;/span&gt;(){
  &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;,&lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;);
   &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;job&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;student&amp;#39;&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;getDesc&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; () =&amp;gt; {
     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;`Myname is &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; and I&amp;#39;m &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;gender&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; I&amp;#39;m a &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;${&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;job&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;`&lt;/span&gt;;
   }
 }

 &lt;span style=&#34;color:#a6e22e&#34;&gt;MaleStudent&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Male&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  尝试看看function是什么样的：&lt;br&gt;
  看起来还ok的样子，但是这个继承是没法继承构造方法的，而且这个prototype直接等于一个实例看着有点膈应..，要应用构造函数的话，可以在子类里面调用父类的apply或者call，类似这样&lt;strong&gt;Person.apply(this,arguments)&lt;/strong&gt;。反正网上js模拟类的方法多得是，看着给人的感觉就是在写&amp;hellip;茴的四种写法..所以具体性能优劣等碰到了再说。&lt;br&gt;
  还有一点要提的是，在阮一峰博客中看到，使用这种方法继承的时候需要在&lt;strong&gt;Male.prototype = new Person(&amp;lsquo;people&amp;rsquo;);&lt;strong&gt;后面添加&lt;/strong&gt;Male.prototype.constructor=Male&lt;/strong&gt;，并且指明了在所有改变prototype之后都需要重新设定constructor，但是我这里尝试添加和没有添加constructor发现这个构造方法都是生效的，instanceof关键字也都是true(讲道理，instanceof 是判断构造函数是否在当前的instance的原型链上面，所以子类实例 instanceof 父类构造函数就应该是true吧)。&lt;br&gt;
  所以说是说需要重新指定constructor，但是并没有找到这么做的现实原因&amp;hellip;&lt;br&gt;
  到这里貌似结束了？不，当我们写ES6以上的语法时候，由于node环境是不支持class语法的，所以我们都是用babel来进行编译的，react的jsx编译也用的babel的编译器，讲道理，最广泛的说法应该是babel编译出来的版本&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_inherits&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;subClass&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;typeof&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;function&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!==&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TypeError&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Super expression must either be null or a function&amp;#34;&lt;/span&gt;); } &lt;span style=&#34;color:#a6e22e&#34;&gt;subClass&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;create&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;prototype&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;constructor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; { &lt;span style=&#34;color:#a6e22e&#34;&gt;value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;subClass&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;writable&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;configurable&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt; } }); &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;_setPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;subClass&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;superClass&lt;/span&gt;); }

&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_setPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;) { &lt;span style=&#34;color:#a6e22e&#34;&gt;_setPrototypeOf&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Object.&lt;span style=&#34;color:#a6e22e&#34;&gt;setPrototypeOf&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_setPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;) { &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;__proto__&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;; }; &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_setPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;o&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt;); }
&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;() {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;_classCallCheck&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;);


  &lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;;
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/*#__PURE__*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;_A&lt;/span&gt;) {
  &lt;span style=&#34;color:#a6e22e&#34;&gt;_inherits&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_A&lt;/span&gt;);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;() {
    &lt;span style=&#34;color:#a6e22e&#34;&gt;_classCallCheck&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_possibleConstructorReturn&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_getPrototypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;).&lt;span style=&#34;color:#a6e22e&#34;&gt;apply&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;this&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;arguments&lt;/span&gt;));
  }

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;;
}(&lt;span style=&#34;color:#a6e22e&#34;&gt;A&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;  忽略check方法咱默认check方法都通过，那么这里具体执行的其实就是  _inherits(B, _A);和getPrototyoeOf().apply(this.arguments)。看样子好像就是首先将父类的赋予子类的prototype，自定义一个constructor，然后父类构造函数绑定。&lt;/p&gt;
&lt;p&gt;  好了，到此为止，这个componentDidMount引出来的发散出来的思考就这些了。不知道为什么，查了一大堆资料，却总觉得我是在挖JavaScript的黑历史&amp;hellip;我相信这些原型链搞出来的继承应该是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Ecma_International&#34; title=&#34;Ecma International&#34;&gt;Ecma International&lt;/a&gt;希望屏蔽掉(这些对象的定义之类的就应该标准化&amp;hellip;)，不希望开发者用到的。而且有了ES6 class和babel之后再用prototype确实给人感觉很蠢&amp;hellip;&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
